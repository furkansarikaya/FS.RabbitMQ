namespace FS.RabbitMQ.Core.Abstractions;

/// <summary>
/// Provides comprehensive context information for a message being processed by a consumer.
/// </summary>
/// <typeparam name="T">The type of the message payload.</typeparam>
/// <remarks>
/// Message context encapsulates all information needed to process a message effectively,
/// including the deserialized payload, routing information, headers, acknowledgment controls,
/// and processing metadata. This comprehensive context enables sophisticated message
/// processing patterns while maintaining clean separation of concerns.
/// 
/// The context provides both read-only information about the message and its routing,
/// as well as control mechanisms for acknowledgment, rejection, and redelivery decisions.
/// This design supports both simple processing scenarios and complex workflows requiring
/// fine-grained control over message lifecycle management.
/// </remarks>
public sealed class MessageContext<T> where T : class
{
    /// <summary>
    /// Gets the deserialized message payload.
    /// </summary>
    /// <value>The strongly-typed message content that was deserialized from the message body.</value>
    /// <remarks>
    /// The payload represents the application-specific data contained in the message.
    /// Deserialization is handled automatically by the messaging infrastructure using
    /// the configured serialization strategy. Type safety is ensured through generic
    /// constraints and runtime validation during message consumption.
    /// </remarks>
    public required T Payload { get; init; }

    /// <summary>
    /// Gets the unique identifier for this message.
    /// </summary>
    /// <value>The message ID that uniquely identifies this message instance, or null if not provided.</value>
    /// <remarks>
    /// Message IDs enable:
    /// - Deduplication logic to prevent duplicate processing
    /// - Correlation with external systems and audit trails
    /// - Debugging and troubleshooting of specific messages
    /// - Implementation of idempotency patterns
    /// 
    /// IDs may be provided by the publisher or automatically generated by the
    /// messaging infrastructure depending on configuration and publishing options.
    /// </remarks>
    public string? MessageId { get; init; }

    /// <summary>
    /// Gets the correlation identifier for tracking related messages.
    /// </summary>
    /// <value>The correlation ID for linking this message to related operations, or null if not provided.</value>
    /// <remarks>
    /// Correlation IDs enable:
    /// - Request-response pattern implementation and tracking
    /// - Distributed tracing across multiple services and operations
    /// - Conversation and workflow correlation
    /// - Business process tracking and audit trails
    /// 
    /// Correlation IDs are particularly important in microservices architectures
    /// where operations span multiple services and require end-to-end tracking.
    /// </remarks>
    public string? CorrelationId { get; init; }

    /// <summary>
    /// Gets the reply-to queue name for response messages.
    /// </summary>
    /// <value>The queue where responses should be sent, or null if no response is expected.</value>
    /// <remarks>
    /// Reply-to information enables:
    /// - Implementation of request-response messaging patterns
    /// - Dynamic response routing based on message requirements
    /// - Temporary reply queue management for RPC scenarios
    /// - Asynchronous response handling in distributed systems
    /// 
    /// When present, consumers can use this information to send responses
    /// or acknowledgments back to the original requester.
    /// </remarks>
    public string? ReplyTo { get; init; }

    /// <summary>
    /// Gets the routing key that was used to deliver this message.
    /// </summary>
    /// <value>The routing key that matched the consumer's binding and caused message delivery.</value>
    /// <remarks>
    /// Routing key information provides:
    /// - Context about how the message was routed to this consumer
    /// - Input for conditional processing logic based on routing patterns
    /// - Information for implementing routing-aware error handling
    /// - Data for metrics and monitoring segmented by routing patterns
    /// 
    /// The routing key may contain hierarchical information that can be
    /// parsed and used for sophisticated message categorization and processing.
    /// </remarks>
    public required string RoutingKey { get; init; }

    /// <summary>
    /// Gets the exchange name where this message was originally published.
    /// </summary>
    /// <value>The name of the exchange that routed this message to the consumer's queue.</value>
    /// <remarks>
    /// Exchange information enables:
    /// - Understanding of message source and routing topology
    /// - Implementation of exchange-specific processing logic
    /// - Metrics and monitoring segmented by message source
    /// - Debugging of routing and delivery issues
    /// 
    /// Exchange names provide context about the message's origin and
    /// the routing infrastructure that delivered it to the consumer.
    /// </remarks>
    public required string ExchangeName { get; init; }

    /// <summary>
    /// Gets the queue name from which this message was consumed.
    /// </summary>
    /// <value>The name of the queue that held this message before consumption.</value>
    /// <remarks>
    /// Queue information provides:
    /// - Context about the message's immediate source
    /// - Support for queue-specific processing logic
    /// - Information for metrics and monitoring by queue
    /// - Data for debugging consumer and routing configurations
    /// 
    /// This is particularly useful in scenarios where a single consumer
    /// processes messages from multiple queues or dynamic queue configurations.
    /// </remarks>
    public required string QueueName { get; init; }

    /// <summary>
    /// Gets the message headers containing metadata and custom properties.
    /// </summary>
    /// <value>A dictionary of header key-value pairs, or null if no headers are present.</value>
    /// <remarks>
    /// Message headers provide:
    /// - Application-specific metadata and processing instructions
    /// - Routing hints and content classification information
    /// - Distributed tracing and observability data
    /// - Integration context for cross-system communication
    /// 
    /// Headers are commonly used for:
    /// - Content-based routing and filtering decisions
    /// - Propagating security and authorization context
    /// - Carrying application-specific flags and configuration
    /// - Implementing header-based message processing patterns
    /// </remarks>
    public IReadOnlyDictionary<string, object>? Headers { get; init; }

    /// <summary>
    /// Gets the content type of the message payload.
    /// </summary>
    /// <value>The MIME type describing the format of the message body, or null if not specified.</value>
    /// <remarks>
    /// Content type information enables:
    /// - Validation of expected message format and structure
    /// - Selection of appropriate deserialization strategies
    /// - Content-based routing and processing decisions
    /// - Interoperability across different technology stacks
    /// 
    /// Common content types include "application/json", "application/xml",
    /// "text/plain", and custom application-specific formats.
    /// </remarks>
    public string? ContentType { get; init; }

    /// <summary>
    /// Gets the content encoding of the message payload.
    /// </summary>
    /// <value>The encoding format applied to the message body, or null if no special encoding is used.</value>
    /// <remarks>
    /// Content encoding information enables:
    /// - Automatic decompression and decoding of message content
    /// - Validation of expected encoding format
    /// - Support for compressed and encoded message payloads
    /// - Interoperability with systems using different encoding strategies
    /// 
    /// Common encodings include "gzip", "deflate", "utf-8", and custom encodings.
    /// </remarks>
    public string? ContentEncoding { get; init; }

    /// <summary>
    /// Gets the timestamp when the message was originally published.
    /// </summary>
    /// <value>The UTC timestamp of message creation, or null if not provided.</value>
    /// <remarks>
    /// Message timestamp enables:
    /// - Age-based processing and expiration logic
    /// - Performance monitoring and latency analysis
    /// - Temporal ordering and sequencing of related messages
    /// - Audit trails and compliance reporting
    /// 
    /// Timestamps are particularly important for time-sensitive processing,
    /// SLA monitoring, and implementing time-based business logic.
    /// </remarks>
    public DateTimeOffset? Timestamp { get; init; }

    /// <summary>
    /// Gets the message type identifier if specified by the publisher.
    /// </summary>
    /// <value>A string identifying the message type for polymorphic processing, or null if not specified.</value>
    /// <remarks>
    /// Message type identification enables:
    /// - Polymorphic message handling with type-specific processing
    /// - Dynamic routing based on message classification
    /// - Version management and schema evolution
    /// - Implementation of command/event pattern variations
    /// 
    /// Type identifiers provide semantic meaning beyond payload structure,
    /// enabling sophisticated message processing and routing strategies.
    /// </remarks>
    public string? MessageType { get; init; }

    /// <summary>
    /// Gets the application identifier of the message publisher.
    /// </summary>
    /// <value>The identifier of the application that published this message, or null if not provided.</value>
    /// <remarks>
    /// Application identification enables:
    /// - Source-based routing and processing decisions
    /// - Security and authorization based on publisher identity
    /// - Monitoring and analytics segmented by publishing application
    /// - Implementation of application-specific processing logic
    /// 
    /// This information is valuable for multi-tenant systems and
    /// scenarios requiring publisher-aware message handling.
    /// </remarks>
    public string? AppId { get; init; }

    /// <summary>
    /// Gets the user identifier associated with the message if specified.
    /// </summary>
    /// <value>The identifier of the user that initiated this message, or null if not provided.</value>
    /// <remarks>
    /// User identification supports:
    /// - User-specific processing and authorization logic
    /// - Audit trails linking messages to specific users
    /// - Personalization and user-context processing
    /// - Compliance with data protection and privacy requirements
    /// 
    /// User context is particularly important in systems requiring
    /// user-aware processing and personalized message handling.
    /// </remarks>
    public string? UserId { get; init; }

    /// <summary>
    /// Gets the priority level of the message if specified.
    /// </summary>
    /// <value>The priority value indicating the relative importance of this message, or null if not specified.</value>
    /// <remarks>
    /// Message priority enables:
    /// - Priority-based processing order and resource allocation
    /// - SLA-aware processing with different service levels
    /// - Queue management with priority-based scheduling
    /// - Implementation of urgent/normal/low priority processing paths
    /// 
    /// Priority values typically range from 0 (lowest) to 255 (highest),
    /// with specific semantics depending on application requirements.
    /// </remarks>
    public byte? Priority { get; init; }

    /// <summary>
    /// Gets a value indicating whether this message is a redelivery.
    /// </summary>
    /// <value><c>true</c> if this message was previously delivered and is being redelivered; otherwise, <c>false</c>.</value>
    /// <remarks>
    /// Redelivery status enables:
    /// - Detection of potential duplicate processing scenarios
    /// - Implementation of redelivery-specific processing logic
    /// - Monitoring and alerting for redelivery patterns
    /// - Conditional processing based on delivery history
    /// 
    /// Messages may be redelivered due to processing failures, timeouts,
    /// consumer restarts, or explicit rejection with requeue requests.
    /// </remarks>
    public bool IsRedelivery { get; init; }

    /// <summary>
    /// Gets the number of times this message has been delivered.
    /// </summary>
    /// <value>The delivery count for this message, starting from 1 for the first delivery.</value>
    /// <remarks>
    /// Delivery count enables:
    /// - Implementation of maximum retry limits and dead letter handling
    /// - Exponential backoff strategies based on attempt count
    /// - Monitoring and alerting for problematic messages
    /// - Conditional processing based on delivery history
    /// 
    /// Delivery count is particularly important for implementing
    /// resilient processing patterns and preventing infinite retry loops.
    /// </remarks>
    public int DeliveryCount { get; init; } = 1;

    /// <summary>
    /// Gets the timestamp when this message was received by the consumer.
    /// </summary>
    /// <value>The UTC timestamp when the consumer received this message for processing.</value>
    /// <remarks>
    /// Reception timestamp enables:
    /// - Measurement of message processing latency and performance
    /// - Implementation of processing timeouts and SLA monitoring
    /// - Audit trails with accurate timing information
    /// - Analysis of consumer processing patterns and bottlenecks
    /// 
    /// This timestamp represents when the message became available to
    /// the consumer for processing, distinct from publication timestamp.
    /// </remarks>
    public DateTimeOffset ReceivedAt { get; init; } = DateTimeOffset.UtcNow;

    /// <summary>
    /// Gets the acknowledgment controller for managing message acknowledgment lifecycle.
    /// </summary>
    /// <value>The controller instance that provides message acknowledgment and rejection operations.</value>
    /// <remarks>
    /// The acknowledgment controller provides:
    /// - Positive acknowledgment to confirm successful processing
    /// - Negative acknowledgment with optional requeue for retry scenarios
    /// - Rejection with dead letter routing for unprocessable messages
    /// - Timeout-based automatic handling for unacknowledged messages
    /// 
    /// Proper acknowledgment handling is essential for message delivery
    /// guarantees and preventing message loss or duplication.
    /// </remarks>
    public required IMessageAcknowledgment Acknowledgment { get; init; }

    /// <summary>
    /// Gets additional metadata about the message processing context.
    /// </summary>
    /// <value>A dictionary containing supplementary context information, or null if no additional data is available.</value>
    /// <remarks>
    /// Context metadata may include:
    /// - Consumer-specific processing information
    /// - Performance metrics and timing data
    /// - Debugging and diagnostic information
    /// - Integration-specific context data
    /// 
    /// This extensibility mechanism allows for framework-specific or
    /// application-specific context information without modifying core interfaces.
    /// </remarks>
    public IReadOnlyDictionary<string, object>? Metadata { get; init; }

    /// <summary>
    /// Gets the age of the message based on its publication timestamp.
    /// </summary>
    /// <value>The duration between message publication and current time, or null if timestamp is not available.</value>
    /// <remarks>
    /// Message age provides:
    /// - Input for time-based processing decisions and expiration logic
    /// - Performance monitoring and latency analysis data
    /// - Support for age-based routing and prioritization
    /// - Implementation of time-sensitive business rules
    /// 
    /// Age calculation uses the publication timestamp when available,
    /// providing insight into message freshness and system latency.
    /// </remarks>
    public TimeSpan? Age => Timestamp.HasValue ? DateTimeOffset.UtcNow - Timestamp.Value : null;

    /// <summary>
    /// Gets the processing latency from message reception to current time.
    /// </summary>
    /// <value>The duration between message reception by the consumer and current time.</value>
    /// <remarks>
    /// Processing latency provides:
    /// - Real-time measurement of consumer processing performance
    /// - Input for timeout detection and SLA monitoring
    /// - Data for performance optimization and capacity planning
    /// - Support for processing-time-based business logic
    /// 
    /// This metric helps identify processing bottlenecks and optimize
    /// consumer performance characteristics.
    /// </remarks>
    public TimeSpan ProcessingLatency => DateTimeOffset.UtcNow - ReceivedAt;

    /// <summary>
    /// Gets a value indicating whether this message should be considered urgent based on its priority.
    /// </summary>
    /// <value><c>true</c> if the message priority indicates urgent processing; otherwise, <c>false</c>.</value>
    /// <remarks>
    /// Urgency assessment provides:
    /// - Quick classification for priority-based processing decisions
    /// - Support for urgent/normal processing path selection
    /// - Input for resource allocation and scheduling decisions
    /// - Implementation of SLA-aware processing strategies
    /// 
    /// The urgency threshold can be configured based on application
    /// requirements and business priority definitions.
    /// </remarks>
    public bool IsUrgent => Priority.HasValue && Priority.Value >= 128; // Threshold for urgent priority

    /// <summary>
    /// Returns a string representation of the message context.
    /// </summary>
    /// <returns>A formatted string containing key message information for logging and debugging.</returns>
    public override string ToString()
    {
        var idInfo = !string.IsNullOrEmpty(MessageId) ? $" ID:{MessageId}" : "";
        var correlationInfo = !string.IsNullOrEmpty(CorrelationId) ? $" Correlation:{CorrelationId}" : "";
        var priorityInfo = Priority.HasValue ? $" Priority:{Priority}" : "";
        var redeliveryInfo = IsRedelivery ? $" (Redelivery #{DeliveryCount})" : "";
        
        return $"Message[{typeof(T).Name}] from {ExchangeName}→{QueueName} via '{RoutingKey}'{idInfo}{correlationInfo}{priorityInfo}{redeliveryInfo}";
    }
}